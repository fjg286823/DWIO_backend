// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#pragma once

#include "../../hash/ITMRepresentationAccess.h"

//__constant__用于指示编译器将变量存储在常量存储区域中。常量存储区域通常是GPU内存的一部分，用于存储在程序运行时不可更改的常量数据,加快访问
static const __constant__ int edgeTable[256] = {0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
                                                0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
                                                0x230, 0x339, 0x33, 0x13a,
                                                0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa,
                                                0x7a6, 0x6af, 0x5a5, 0x4ac,
                                                0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
                                                0xc6c, 0xd65, 0xe6f, 0xf66,
                                                0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6,
                                                0x9fa, 0x8f3, 0xbf9, 0xaf0,
                                                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
                                                0x7c0, 0x6c9, 0x5c3, 0x4ca,
                                                0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca,
                                                0xcc6, 0xdcf, 0xec5, 0xfcc,
                                                0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
                                                0x15c, 0x55, 0x35f, 0x256,
                                                0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6,
                                                0x6fa, 0x7f3, 0x4f9, 0x5f0,
                                                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
                                                0xca0, 0xda9, 0xea3, 0xfaa,
                                                0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a,
                                                0x936, 0x83f, 0xb35, 0xa3c,
                                                0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
                                                0x69c, 0x795, 0x49f, 0x596,
                                                0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406,
                                                0x30a, 0x203, 0x109, 0x0};

static const __constant__ int triangleTable[256][16] = {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
                                                        {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
                                                        {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
                                                        {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
                                                        {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
                                                        {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
                                                        {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
                                                        {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
                                                        {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
                                                        {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
                                                        {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
                                                        {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
                                                        {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
                                                        {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
                                                        {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
                                                        {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
                                                        {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
                                                        {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
                                                        {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
                                                        {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
                                                        {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
                                                        {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
                                                        {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
                                                        {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
                                                        {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
                                                        {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
                                                        {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
                                                        {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
                                                        {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
                                                        {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
                                                        {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
                                                        {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
                                                        {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
                                                        {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
                                                        {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
                                                        {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
                                                        {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
                                                        {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
                                                        {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
                                                        {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
                                                        {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
                                                        {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
                                                        {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
                                                        {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
                                                        {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
                                                        {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
                                                        {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
                                                        {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
                                                        {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
                                                        {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
                                                        {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
                                                        {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
                                                        {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
                                                        {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
                                                        {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
                                                        {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
                                                        {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
                                                        {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
                                                        {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
                                                        {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
                                                        {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
                                                        {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
                                                        {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
                                                        {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
                                                        {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
                                                        {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
                                                        {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
                                                        {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
                                                        {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
                                                        {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
                                                        {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
                                                        {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
                                                        {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
                                                        {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
                                                        {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
                                                        {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
                                                        {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
                                                        {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
                                                        {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
                                                        {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
                                                        {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
                                                        {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
                                                        {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
                                                        {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
                                                        {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
                                                        {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
                                                        {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
                                                        {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
                                                        {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
                                                        {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
                                                        {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
                                                        {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
                                                        {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
                                                        {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
                                                        {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
                                                        {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
                                                        {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
                                                        {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
                                                        {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
                                                        {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
                                                        {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
                                                        {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
                                                        {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
                                                        {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
                                                        {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
                                                        {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
                                                        {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
                                                        {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
                                                        {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
                                                        {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
                                                        {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                                                        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};

template <class TVoxel>
// 看这个点周围是否有点，如果周围8个点有一个没点就返回false
__device__ inline bool findPointNeighbors(Vector3f *p, float *tsdf, Vector3i blockLocation, const TVoxel *localVBA, const ITMHashEntry *hashTable)
{
    int vmIndex;
    Vector3i localBlockLocation;

    localBlockLocation = blockLocation + Vector3i(0, 0, 0);
    p[0] = localBlockLocation.cast<float>();                                                          // 此为体素位置
    tsdf[0] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf); // 修改查找逻辑
    if (!vmIndex || tsdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 0);
    p[1] = localBlockLocation.cast<float>();
    tsdf[1] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 0);
    p[2] = localBlockLocation.cast<float>();
    tsdf[2] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 0);
    p[3] = localBlockLocation.cast<float>();
    tsdf[3] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 0, 1);
    p[4] = localBlockLocation.cast<float>();
    tsdf[4] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 1);
    p[5] = localBlockLocation.cast<float>();
    tsdf[5] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 1);
    p[6] = localBlockLocation.cast<float>();
    tsdf[6] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 1);
    p[7] = localBlockLocation.cast<float>();
    tsdf[7] = TVoxel::valueToFloat(readVoxel(localVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[7] == 1.0f)
        return false;

    return true;
}

template <class TVoxel>
// 看这个点周围是否有点，如果周围8个点有一个没点就返回false
__device__ inline bool findPointNeighborsCpu(Vector3f *p, float *tsdf, Vector3i blockLocation, const TVoxel *globalVBA, const ITMHashEntry *hashTable)
{
    int vmIndex;
    Vector3i localBlockLocation;
    // printf("2\n");
    localBlockLocation = blockLocation + Vector3i(0, 0, 0);
    p[0] = localBlockLocation.cast<float>();                                                              // 此为体素位置
    tsdf[0] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf); // 修改查找逻辑
    // printf("3\n");
    if (!vmIndex || tsdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 0);
    p[1] = localBlockLocation.cast<float>();
    tsdf[1] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 0);
    p[2] = localBlockLocation.cast<float>();
    tsdf[2] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 0);
    p[3] = localBlockLocation.cast<float>();
    tsdf[3] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 0, 1);
    p[4] = localBlockLocation.cast<float>();
    tsdf[4] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 1);
    p[5] = localBlockLocation.cast<float>();
    tsdf[5] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 1);
    p[6] = localBlockLocation.cast<float>();
    tsdf[6] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 1);
    p[7] = localBlockLocation.cast<float>();
    tsdf[7] = TVoxel::valueToFloat(readVoxelCpu(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[7] == 1.0f)
        return false;

    return true;
}

// 看这个点周围是否有点，如果周围8个点有一个没点就返回false
inline bool findPointNeighbors_new_submap(Vector3f *p, float *tsdf, Vector3i blockLocation,
                                          std::map<int, DWIO::BlockData *> &blocks, const ITMHashEntry *hashTable)
{
    int vmIndex;
    Vector3i localBlockLocation;
    // printf("2\n");
    localBlockLocation = blockLocation + Vector3i(0, 0, 0);
    p[0] = localBlockLocation.cast<float>();                                                                       // 此为体素位置
    tsdf[0] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf); // 修改查找逻辑
    // printf("3\n");
    if (!vmIndex || tsdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 0);
    p[1] = localBlockLocation.cast<float>();
    tsdf[1] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 0);
    p[2] = localBlockLocation.cast<float>();
    tsdf[2] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 0);
    p[3] = localBlockLocation.cast<float>();
    tsdf[3] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 0, 1);
    p[4] = localBlockLocation.cast<float>();
    tsdf[4] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 1);
    p[5] = localBlockLocation.cast<float>();
    tsdf[5] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 1);
    p[6] = localBlockLocation.cast<float>();
    tsdf[6] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 1);
    p[7] = localBlockLocation.cast<float>();
    tsdf[7] = ITMVoxel_d::valueToFloat(readVoxel_new_submap(blocks, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[7] == 1.0f)
        return false;

    return true;
}
//                                                               一个局部子图内的体素的坐标
inline bool findPointNeighborsMulti(Vector3f *p, float *sdf, Vector3i blockLocation, std::map<uint32_t, DWIO::submap *> &submaps_, uint32_t submap_index)
{
    int vmIndex;
    Vector3f localBlockLocation;
    Vector3f blockLocation_f;
    blockLocation_f.x() = (float)blockLocation.x();
    blockLocation_f.y() = (float)blockLocation.y();
    blockLocation_f.z() = (float)blockLocation.z();
    localBlockLocation = blockLocation_f + Vector3f(0.0f, 0.0f, 0.0f); // 转到世界坐标系下
    p[0] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[0] = readFromSDF_float_interpolated(submaps_, p[0], vmIndex);
    if (!vmIndex || sdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0f, 0.0f, 0.0f);
    p[1] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[1] = readFromSDF_float_interpolated(submaps_, p[1], vmIndex);
    if (!vmIndex || sdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 1.0, 0.0);
    p[2] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[2] = readFromSDF_float_interpolated(submaps_, p[2], vmIndex);
    if (!vmIndex || sdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 1.0, 0.0);
    p[3] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[3] = readFromSDF_float_interpolated(submaps_, p[3], vmIndex);
    if (!vmIndex || sdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 0.0, 1.0);
    p[4] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[4] = readFromSDF_float_interpolated(submaps_, p[4], vmIndex);
    if (!vmIndex || sdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 0.0, 1.0);
    p[5] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[5] = readFromSDF_float_interpolated(submaps_, p[5], vmIndex);
    if (!vmIndex || sdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 1.0, 1.0);
    p[6] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[6] = readFromSDF_float_interpolated(submaps_, p[6], vmIndex);
    if (!vmIndex || sdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 1.0, 1.0);
    p[7] = submaps_[submap_index]->local_rotation.cast<float>() * localBlockLocation + submaps_[submap_index]->local_translation.cast<float>();
    sdf[7] = readFromSDF_float_interpolated(submaps_, p[7], vmIndex);
    if (!vmIndex || sdf[7] == 1.0f)
        return false;

    return true;
}

template <class TVoxel>
// 看这个点周围是否有点，如果周围8个点有一个没点就返回false
inline bool findPointNeighborsGlobal(Vector3f *p, float *tsdf, Vector3i blockLocation, const TVoxel *globalVBA, const ITMHashEntry *hashTable)
{
    int vmIndex;
    Vector3i localBlockLocation;
    // printf("2\n");
    localBlockLocation = blockLocation + Vector3i(0, 0, 0);
    p[0] = localBlockLocation.cast<float>();                                                                 // 此为体素位置
    tsdf[0] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf); // 修改查找逻辑
    // printf("3\n");
    if (!vmIndex || tsdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 0);
    p[1] = localBlockLocation.cast<float>();
    tsdf[1] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 0);
    p[2] = localBlockLocation.cast<float>();
    tsdf[2] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 0);
    p[3] = localBlockLocation.cast<float>();
    tsdf[3] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 0, 1);
    p[4] = localBlockLocation.cast<float>();
    tsdf[4] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 0, 1);
    p[5] = localBlockLocation.cast<float>();
    tsdf[5] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(1, 1, 1);
    p[6] = localBlockLocation.cast<float>();
    tsdf[6] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation + Vector3i(0, 1, 1);
    p[7] = localBlockLocation.cast<float>();
    tsdf[7] = TVoxel::valueToFloat(readVoxelGlobal(globalVBA, hashTable, localBlockLocation, vmIndex).tsdf);
    if (!vmIndex || tsdf[7] == 1.0f)
        return false;

    return true;
}

__device__ inline Vertex sdfInterp(const Vector3f &p1, const Vector3f &p2, float valp1, float valp2, float factor, float3 color)
{
    Vertex res;
    res.c = color;

    if (fabs(0.0f - valp1) < 0.00001f)
    {
        res.p.x = p1.x() * factor;
        res.p.y = p1.y() * factor;
        res.p.z = p1.z() * factor;
        return res;
    }
    if (fabs(0.0f - valp2) < 0.00001f)
    {
        res.p.x = p2.x() * factor;
        res.p.y = p2.y() * factor;
        res.p.z = p2.z() * factor;
        return res;
    }
    if (fabs(valp1 - valp2) < 0.00001f)
    {
        res.p.x = p1.x() * factor;
        res.p.y = p1.y() * factor;
        res.p.z = p1.z() * factor;
        return res;
    }

    Vector3f temp = p1 + ((0.0f - valp1) / (valp2 - valp1)) * (p2 - p1);
    temp = temp * factor;

    res.p.x = temp.x();
    res.p.y = temp.y();
    res.p.z = temp.z();
    return res;
}

template <class TVoxel>
__device__ inline int
buildVertList(Vertex *vertList, Vector3i globalPos, Vector3i localPos, const TVoxel *localVBA, const ITMHashEntry *hashTable, float factor)
{
    Vector3f points[8];
    float tsdfVals[8];
    // 如果当前点周围8个点有一个没在在gpu中，则返回
    if (!findPointNeighbors(points, tsdfVals, globalPos + localPos, localVBA, hashTable))
        return -1;

    int vmIndex;

    TVoxel v = readVoxel(localVBA, hashTable, globalPos + localPos, vmIndex);
    float3 color;
    color.x = static_cast<float>(v.clr.x);
    color.y = static_cast<float>(v.clr.y);
    color.z = static_cast<float>(v.clr.z);

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}

template <class TVoxel>
__device__ inline int
buildVertListCpu(Vertex *vertList, Vector3i globalPos, Vector3i localPos, const TVoxel *localVBA, const ITMHashEntry *hashTable, float factor)
{
    Vector3f points[8];
    float tsdfVals[8];
    // 如果当前点周围8个点有一个没在在gpu中，则返回
    // if (!findPointNeighbors(points, tsdfVals, globalPos + localPos, localVBA, hashTable)) return -1;
    if (!findPointNeighborsCpu(points, tsdfVals, globalPos + localPos, localVBA, hashTable))
        return -1;

    int vmIndex;

    TVoxel v = readVoxelCpu(localVBA, hashTable, globalPos + localPos, vmIndex);
    float3 color;
    color.x = static_cast<float>(v.clr.x);
    color.y = static_cast<float>(v.clr.y);
    color.z = static_cast<float>(v.clr.z);

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}

template <class TVoxel>
__device__ inline int buildVertListGlobal(Vertex *vertList, Vector3i globalPos, Vector3i localPos, const TVoxel *globalVBA, const ITMHashEntry *hashTable, float factor)
{
    Vector3f points[8];
    float tsdfVals[8];
    // 如果当前点周围8个点有一个没在在gpu中，则返回
    if (!findPointNeighborsGlobal(points, tsdfVals, globalPos + localPos, globalVBA, hashTable))
        return -1;

    int vmIndex;

    TVoxel v = readVoxelGlobal(globalVBA, hashTable, globalPos + localPos, vmIndex);
    float3 color;
    color.x = static_cast<float>(v.clr.x);
    color.y = static_cast<float>(v.clr.y);
    color.z = static_cast<float>(v.clr.z);

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}

__device__ inline int buildVertList_new_submap(Vertex *vertList, Vector3i globalPos, Vector3i localPos,
                                               std::map<int, DWIO::BlockData *> &blocks, const ITMHashEntry *hashTable, float factor)
{
    Vector3f points[8];
    float tsdfVals[8];

    if (!findPointNeighbors_new_submap(points, tsdfVals, globalPos + localPos, blocks, hashTable))
        return -1;

    int vmIndex;

    ITMVoxel_d v = readVoxel_new_submap(blocks, hashTable, globalPos + localPos, vmIndex);
    float3 color;
    color.x = static_cast<float>(v.clr.x);
    color.y = static_cast<float>(v.clr.y);
    color.z = static_cast<float>(v.clr.z);

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}

__device__ inline int buildVertListMulti(Vertex *vertList, Vector3i globalPos, Vector3i localPos,
                                         std::map<uint32_t, DWIO::submap *> &submaps_, u_int32_t submap_index, float factor)
{
    Vector3f points[8];
    float tsdfVals[8];

    if (!findPointNeighborsMulti(points, tsdfVals, globalPos + localPos, submaps_, submap_index))
        return -1;

    int vmIndex;

    ITMVoxel_d v = readVoxel_new_submap(submaps_[submap_index]->blocks_, submaps_[submap_index]->hashEntries_submap->GetData(MEMORYDEVICE_CPU),
                                        globalPos + localPos, vmIndex);

    // //这里是不是要判断这个本身的点是否有值
    // if(!vmIndex)
    //     return -1;

    float3 color;
    color.x = static_cast<float>(v.clr.x);
    color.y = static_cast<float>(v.clr.y);
    color.z = static_cast<float>(v.clr.z);

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)/*|| edgeTable[cubeIndex] == 255*/
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}

inline bool findPointNeighborsMultiBox(Vector3f *p, float *sdf, Vector3i blockLocation, std::map<uint32_t, DWIO::submap *> &submaps_)
{
    int vmIndex;
    Vector3f localBlockLocation;
    Vector3f blockLocation_f;
    blockLocation_f.x() = (float)blockLocation.x();
    blockLocation_f.y() = (float)blockLocation.y();
    blockLocation_f.z() = (float)blockLocation.z();
    localBlockLocation = blockLocation_f + Vector3f(0.0f, 0.0f, 0.0f);
    p[0] = localBlockLocation ;
    sdf[0] = readFromSDF_float_interpolated(submaps_, p[0], vmIndex);
    if (!vmIndex || sdf[0] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0f, 0.0f, 0.0f);
    p[1] = localBlockLocation;
    sdf[1] = readFromSDF_float_interpolated(submaps_, p[1], vmIndex);
    if (!vmIndex || sdf[1] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 1.0, 0.0);
    p[2] = localBlockLocation;
    sdf[2] = readFromSDF_float_interpolated(submaps_, p[2], vmIndex);
    if (!vmIndex || sdf[2] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 1.0, 0.0);
    p[3] = localBlockLocation;
    sdf[3] = readFromSDF_float_interpolated(submaps_, p[3], vmIndex);
    if (!vmIndex || sdf[3] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 0.0, 1.0);
    p[4] = localBlockLocation;
    sdf[4] = readFromSDF_float_interpolated(submaps_, p[4], vmIndex);
    if (!vmIndex || sdf[4] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 0.0, 1.0);
    p[5] = localBlockLocation;
    sdf[5] = readFromSDF_float_interpolated(submaps_, p[5], vmIndex);
    if (!vmIndex || sdf[5] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(1.0, 1.0, 1.0);
    p[6] = localBlockLocation;
    sdf[6] = readFromSDF_float_interpolated(submaps_, p[6], vmIndex);
    if (!vmIndex || sdf[6] == 1.0f)
        return false;

    localBlockLocation = blockLocation_f + Vector3f(0.0, 1.0, 1.0);
    p[7] = localBlockLocation;
    sdf[7] = readFromSDF_float_interpolated(submaps_, p[7], vmIndex);
    if (!vmIndex || sdf[7] == 1.0f)
        return false;

    return true;
}

__device__ inline int buildVertListMultiBox(Vertex *vertList, Vector3i globalPos, Vector3i localPos,
                                         std::map<uint32_t, DWIO::submap *> &submaps_,float factor)
{

    Vector3f points[8];
    float tsdfVals[8];

    if (!findPointNeighborsMultiBox(points, tsdfVals, globalPos + localPos, submaps_))
        return -1;

    int vmIndex;
    //遍历子图找到一个点就算成功
    // ITMVoxel_d v = readVoxel_new_submap(submaps_[submap_index]->blocks_, submaps_[submap_index]->hashEntries_submap->GetData(MEMORYDEVICE_CPU),
    //                                     globalPos + localPos, vmIndex);
    //
    // float3 color;
    // color.x = static_cast<float>(v.clr.x);
    // color.y = static_cast<float>(v.clr.y);
    // color.z = static_cast<float>(v.clr.z);
    float3 color;
    color.x = 254;
    color.y = 254;
    color.z = 254;

    int cubeIndex = 0;
    if (tsdfVals[0] < 0)
        cubeIndex |= 1;
    if (tsdfVals[1] < 0)
        cubeIndex |= 2;
    if (tsdfVals[2] < 0)
        cubeIndex |= 4;
    if (tsdfVals[3] < 0)
        cubeIndex |= 8;
    if (tsdfVals[4] < 0)
        cubeIndex |= 16;
    if (tsdfVals[5] < 0)
        cubeIndex |= 32;
    if (tsdfVals[6] < 0)
        cubeIndex |= 64;
    if (tsdfVals[7] < 0)
        cubeIndex |= 128;

    if (edgeTable[cubeIndex] == 0)/*|| edgeTable[cubeIndex] == 255*/
        return -1;

    if (edgeTable[cubeIndex] & 1)
        vertList[0] = sdfInterp(points[0], points[1], tsdfVals[0], tsdfVals[1], factor, color);
    if (edgeTable[cubeIndex] & 2)
        vertList[1] = sdfInterp(points[1], points[2], tsdfVals[1], tsdfVals[2], factor, color);
    if (edgeTable[cubeIndex] & 4)
        vertList[2] = sdfInterp(points[2], points[3], tsdfVals[2], tsdfVals[3], factor, color);
    if (edgeTable[cubeIndex] & 8)
        vertList[3] = sdfInterp(points[3], points[0], tsdfVals[3], tsdfVals[0], factor, color);
    if (edgeTable[cubeIndex] & 16)
        vertList[4] = sdfInterp(points[4], points[5], tsdfVals[4], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 32)
        vertList[5] = sdfInterp(points[5], points[6], tsdfVals[5], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 64)
        vertList[6] = sdfInterp(points[6], points[7], tsdfVals[6], tsdfVals[7], factor, color);
    if (edgeTable[cubeIndex] & 128)
        vertList[7] = sdfInterp(points[7], points[4], tsdfVals[7], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 256)
        vertList[8] = sdfInterp(points[0], points[4], tsdfVals[0], tsdfVals[4], factor, color);
    if (edgeTable[cubeIndex] & 512)
        vertList[9] = sdfInterp(points[1], points[5], tsdfVals[1], tsdfVals[5], factor, color);
    if (edgeTable[cubeIndex] & 1024)
        vertList[10] = sdfInterp(points[2], points[6], tsdfVals[2], tsdfVals[6], factor, color);
    if (edgeTable[cubeIndex] & 2048)
        vertList[11] = sdfInterp(points[3], points[7], tsdfVals[3], tsdfVals[7], factor, color);

    return cubeIndex;
}